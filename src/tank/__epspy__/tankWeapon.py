## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __idiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov / v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __idiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov / v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 1) import header;
import header
# (Line 2) var weaponSaver = 0;
weaponSaver = EUDCreateVariables(1)
_IGVA([weaponSaver], lambda: [0])
# (Line 3) const ap = 30;
ap = _CGFW(lambda: [30], 1)[0]
# (Line 4) const weaponList = [
# (Line 6) header.List[0*3+1],     156,    24, ap+ 27,      3,     -1,//corsair
# (Line 7) header.List[0*3+2],     152,   	 7,     50,      4,     -1,//scout
# (Line 9) header.List[1*3+1],     150,    30, ap+ 10,      3,     -1,//shuttle
# (Line 10) header.List[1*3+2],     152,    32,     30,      4,     -1,//arbiter
# (Line 12) header.List[2*3+1],     172,    30, ap+ 15,      3,     -1,//rhyno
# (Line 13) header.List[2*3+2],     172,    28,     34,      4,     -1,//kakaru
# (Line 15) header.List[3*3+1],     172,    44, ap+ 26,      3,     -1,//carrier
# (Line 16) header.List[3*3+2],     142,    10,     35,      4,     16,//mojo
# (Line 18) header.List[4*3+1],     205,    40, ap+ 10,      3,     -1,//mutal
# (Line 19) header.List[4*3+2],     171,     5,     60,      4,     -1,//guard
# (Line 21) header.List[5*3+1],     150,    27, ap+ 25,      3,     -1,//wraith
# (Line 22) header.List[5*3+2],     142,    25,     35,      4,     -1,//battle
# (Line 24) header.List[6*3+1],     143,    48, ap+  2,      3,     0, //SV
# (Line 25) header.List[6*3+2],     143,     3,     65,      4,     -1,//battle H
# (Line 27) header.List[7*3+1],     150,   	64, ap+  5,      3,     -1,//drop
# (Line 28) header.List[7*3+2],     143,    1,       0,      4,     -1,//mine H wraith
# (Line 30) header.List[8*3+1],     171,   	32, ap+ 15,      3,     1,//queen
# (Line 31) header.List[8*3+2],     142,   	 5,      7,      4,     -1,//scourge spine
# (Line 33) header.List[9*3+1],     172,    10, ap+  3,      3,     7,//over H
# (Line 34) header.List[9*3+2],     205,   	34,     21,      4,     -1//over
# (Line 36) ];
weaponList = _CGFW(lambda: [_ARR(FlattenList([header.List[0 * 3 + 1], 156, 24, ap + 27, 3, -1, header.List[0 * 3 + 2], 152, 7, 50, 4, -1, header.List[1 * 3 + 1], 150, 30, ap + 10, 3, -1, header.List[1 * 3 + 2], 152, 32, 30, 4, -1, header.List[2 * 3 + 1], 172, 30, ap + 15, 3, -1, header.List[2 * 3 + 2], 172, 28, 34, 4, -1, header.List[3 * 3 + 1], 172, 44, ap + 26, 3, -1, header.List[3 * 3 + 2], 142, 10, 35, 4, 16, header.List[4 * 3 + 1], 205, 40, ap + 10, 3, -1, header.List[4 * 3 + 2], 171, 5, 60, 4, -1, header.List[5 * 3 + 1], 150, 27, ap + 25, 3, -1, header.List[5 * 3 + 2], 142, 25, 35, 4, -1, header.List[6 * 3 + 1], 143, 48, ap + 2, 3, 0, header.List[6 * 3 + 2], 143, 3, 65, 4, -1, header.List[7 * 3 + 1], 150, 64, ap + 5, 3, -1, header.List[7 * 3 + 2], 143, 1, 0, 4, -1, header.List[8 * 3 + 1], 171, 32, ap + 15, 3, 1, header.List[8 * 3 + 2], 142, 5, 7, 4, -1, header.List[9 * 3 + 1], 172, 10, ap + 3, 3, 7, header.List[9 * 3 + 2], 205, 34, 21, 4, -1]))], 1)[0]
# (Line 38) function setWeapon(unitType)
# (Line 39) {
@EUDFunc
def f_setWeapon(unitType):
    # (Line 40) for(var i=0; i<20; i++)
    i = EUDVariable()
    i << (0)
    if EUDWhile()(i >= 20, neg=True):
        def _t2():
            i.__iadd__(1)
        # (Line 41) {
        # (Line 42) const index = i*6;
        index = i * 6
        # (Line 43) if(weaponList[index] == unitType)
        if EUDIf()(weaponList[index] == unitType):
            # (Line 44) {
            # (Line 45) if(weaponSaver != weaponList[index])
            if EUDIf()(weaponSaver == weaponList[index], neg=True):
                # (Line 46) {
                # (Line 47) weaponSaver = weaponList[index];
                weaponSaver << (weaponList[index])
                # (Line 49) dwwrite(0x6564E0 + 1992 + 54 * 4, weaponList[index +1]);
                f_dwwrite(0x6564E0 + 1992 + 54 * 4, weaponList[index + 1])
                # (Line 51) wwrite(0x6564E0 + 4768  + 54 * 2, weaponList[index +2]+40);
                f_wwrite(0x6564E0 + 4768 + 54 * 2, weaponList[index + 2] + 40)
                # (Line 52) wwrite(0x6564E0 + 3048  + 54 * 2, weaponList[index +2]+20);
                f_wwrite(0x6564E0 + 3048 + 54 * 2, weaponList[index + 2] + 20)
                # (Line 53) wwrite(0x6564E0 + 936   + 54 * 2, weaponList[index +2]);
                f_wwrite(0x6564E0 + 936 + 54 * 2, weaponList[index + 2])
                # (Line 55) wwrite(0x6564E0 + 2512  + 54 * 2, weaponList[index +3]);
                f_wwrite(0x6564E0 + 2512 + 54 * 2, weaponList[index + 3])
                # (Line 57) bwrite(0x6564E0 + 3448  + 54 * 1, weaponList[index +4]);
                f_bwrite(0x6564E0 + 3448 + 54 * 1, weaponList[index + 4])
                # (Line 58) }
                # (Line 60) return weaponList[index+5];
            EUDEndIf()
            EUDReturn(weaponList[index + 5])
            # (Line 61) }
            # (Line 62) }
        EUDEndIf()
        # (Line 63) }
        EUDSetContinuePoint()
        _t2()
    EUDEndWhile()
