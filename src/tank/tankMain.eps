import header;
import util.utilEud;
import tank.tankAim;
import tank.tankBullet;
import tank.tankSelect;
import physics;
import customText3 as ct; 

const tankEpd = EUDArray(6);
const locList = [$L('p1'), $L('p2'), $L('p3'), $L('p4'), $L('p5'), $L('p6')];

function toggleDisable(index);
function newTank(targetPlayer, unitType)
{
    if(unitType)
    {
        const locID = locList[targetPlayer];
        tankEpd[targetPlayer] = epdread_epd(EPD(0x628438));
        CreateUnit(1, unitType, locID+1, targetPlayer);
        //initialize
        utilEud.setRemainingBuildtime(tankEpd[targetPlayer], header.maxbuildtime);
        tankAim.setAngle(tankEpd[targetPlayer], 300);
        physics.setVxy(tankEpd[targetPlayer], 0, 10);
        // change ui
        const bullet = tankBullet.getBullet(unitType, utilEud.getDeath(targetPlayer, header.bulletQ));
        utilEud.setBuildQueue1(tankEpd[targetPlayer], bullet);

        toggleDisable(targetPlayer, 0);
        CenterView(locID+1);
    }

}

function removeTank(targetPlayer)
{
    tankEpd[targetPlayer] = 0;
}
function getTankEpd(targetPlayer)
{
	return tankEpd[targetPlayer];
}

function checkDeath(targetPlayer)
{
    if(Deaths(targetPlayer, Exactly, 1, utilEud.getUnitType(tankEpd[targetPlayer])))
        return 1;
    else
        return 0;
}
function controlTank(targetPlayer)
{// 키인식으로 
    const angleNum = 4; //단위
    const unitEpd = getTankEpd(targetPlayer);
    //prevent Error
    //if(unitEpd == 0) return -1;
    const power = utilEud.getRemainingBuildtime(unitEpd);
    const angle = tankAim.getAngle(unitEpd);

    const locID = $L('loc_tank');
    const orderID = utilEud.getOrderID(unitEpd);
    const keyValue = utilEud.getDeath(targetPlayer, header.keydeath);

    if(orderID == 6)  // while moving
    	tankAim.clearAngle(targetPlayer);

    if(1 == keyValue)
    {// angle UP
        tankAim.setAngle(unitEpd, angle + angleNum);
        tankAim.showLaunchAngle(unitEpd);
    }
    else if(2 == keyValue)
    {// angle DOWN
        tankAim.setAngle(unitEpd, angle - angleNum);
        tankAim.showLaunchAngle(unitEpd);
    }
    else if (4 == keyValue && Accumulate(targetPlayer, Exactly, 0, Gas))
    {// shoot inital key press
        //initialize 
        utilEud.setRemainingBuildtime(unitEpd, header.maxbuildtime);
        SetResources(targetPlayer, SetTo, 1, Gas);
        //key delay
        SetDeaths(targetPlayer, SetTo, 0, 217);
    }
    else if (4 != keyValue && Accumulate(targetPlayer, Exactly, 1, Gas))
    {// end key press 
        SetDeaths(targetPlayer, Add, 1, 217);
    }
    else if (4 == keyValue && Accumulate(targetPlayer, Exactly, 1, Gas))
    {
        utilEud.setRemainingBuildtime(unitEpd, power -2);
        SetDeaths(targetPlayer, SetTo, 0, 217);
    }
    else if (8 == keyValue && Switch(targetPlayer, Cleared))
    {// change weapon
        //const chatPtr = dwread_epd(EPD(0x640B58));
        ct.printP(targetPlayer, ""); // ct.cp는 모두에게 출력
        ct.printP(targetPlayer, "\x13[ 무기 교체 ] ");
        //dwwrite_epd(EPD(0x640B58), chatPtr);
        tankBullet.toggleBullet(unitEpd);
        SetSwitch(targetPlayer, Set);
    }
    if(8 != keyValue && Switch(targetPlayer, Set))
    {// change weapon keydelay
        SetSwitch(targetPlayer, Clear);
    }


    if (Deaths(targetPlayer, AtLeast, 8, 217) || power == 0)
    {// end key press for 1sec
        utilEud.setRemainingBuildtime(unitEpd, header.maxbuildtime);
        SetDeaths(targetPlayer, SetTo, 0, 217);
        SetResources(targetPlayer, SetTo, 0, Gas);
        tankAim.clearAngle(targetPlayer);
        // temp storage
        utilEud.setKillCount(unitEpd, (header.maxbuildtime+1) - power); 
        return unitEpd;
    }
    else 
        return 0;
    
}

function renderTank()
{//tank physics
    for(var i=0; i<6; i++)
    {
        if(tankEpd[i])
        {
            const unitType = utilEud.getUnitType(tankEpd[i]);
            MoveLocation($L('locTank')+1, unitType, i, 'Anywhere');
            //collision
            if(Bring($P8, Exactly, 0, '(buildings)', $L('locTank')+1))
            {
                physics.renderUnit(tankEpd[i], 0);
            }
        }
    }
}

function selectTank()
{
    if(tankSelect.isSelecting())
    {
        tankSelect.selectScreen();
        return 0;
    }
    else
    {
        EUDPlayerLoop()();
        const p = getcurpl();
        if(p<6)
        {
            const tankType = utilEud.getDeath(p, header.tankType);
            if(tankType) // 0 or sth
            {
                newTank(p, tankType);
            }
            
        }
        EUDEndPlayerLoop();
        return 1;
    }
}

function shootMissile(index)
{
    tankBullet.shoot(tankEpd[index]);
}

function toggleDisable(index, status)
{
    const unitEpd = tankEpd[index];
    const statusFlag = dwread_epd(unitEpd + 0x0DC / 4);
    const disableFlag = 0x1000;

    if(statusFlag == (statusFlag | disableFlag) && status == 1)
    {// isDisabled -> enable

        SetMemoryEPD(unitEpd + 0x0DC / 4, Subtract, disableFlag);
    }
    else if(status == 0)
    {// isNormal -> disable
        SetMemoryEPD(unitEpd + 0x0DC / 4, SetTo, statusFlag | disableFlag);
    }
}
